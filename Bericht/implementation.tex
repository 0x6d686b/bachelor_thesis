\section{GraphList}
Wie in Abschnitt \ref{aufg6:entscheidungsbaum} erklärt wurde, brauchen wir eine Liste, die alle nötigen Informationen zu den Knoten beinhaltet. Da die Grösse des Arrays variabel ist und wir zum grössten Teil einen index-basierten Zugriff benötigen, haben wir uns entschieden die Datnestruktur $java.util.ArrayList$ mit Generics zu verwenden. Eine generische ArrayList erlaubt es genau zu definieren, welche Elemente/Datentypen einer ArrayList hinzugefügt werden dürfen. Ausserdem brauchen wir für eine tabellarische Form ein 2-dimensionales ArrayList. Um dies zu erreichen, wird ein ArrayList in einem ArrayList definiert. Somit entspricht der erste ArrayList der Spalten und die zweite der Zeilen dieser Spalten. \\
Dementsprechend sieht die Initialisierung des ArrayLists so aus:

\lstinputlisting[label=src:graphListInitialization,caption=Initialisierung der Liste]{code/graphlist_initialize.java}

\subsection{Node}
Für die Speicherung der Daten wurde eine Klasse $Node$ erstellt, welche die Werte über die Knoten beinhaltet. Weil wir nun mehrere Informationen zu den einzelnen Knoten haben, haben wir uns entschieden, neben den Auflistungen in \ref{aufg6:entscheidungsbaum} auch noch weitere Daten in der Liste abzuspeichern, um Redundanz zu vermeiden. Deshalb werden neu auch Koordinaten zu den Knoten und die dazugehörigen Windvektoren in der Liste abgelegt. \\
Demzufolge enthält die Klasse folgende Informationen:
\begin{itemize}
\item \textbf{TimeOfArrival}: Die Dauer vom Anfangsknoten bis zu diesem Knoten.
\item \textbf{Previous Node}: Die Referenz zum vorherigen Knoten.
\item \textbf{Coordinate}: Breiten- und Längengrade des Knotens.
\item \textbf{WindVektor}: Der Windvektor $(u, v)$ an diesem Knoten.
\end{itemize}

Desweiteren erbt diese Klasse von der Interface $Comparable$, um Vergleiche zwischen den Knoten zu ermöglichen. Infolgedessen ist es möglich, die Klasse $Collections$ zu benutzen, welche nützliche Methoden für Listen wie $min()$, $max()$, $sort()$ etc. enthält. Wir machen in unserem Code von der $min()$-Methode Gebrauch, um den Knoten mit dem kleinsten TimeOfArrival in einer Spalte zu finden. \\

Als nächstes wurde innerhalb der ArrayList eine sogenannte LinkedList implementiert. Jeder Knoten beinhaltet eine Referenz zum vorherigen Knoten und der Anfangsknoten hat eine Referenz auf sich selbst. Dementsprechend braucht man nicht durch alle Knoten zu iterieren um einen Pfad zu zeichnen, sondern es reicht den Knoten zu wählen, von dem man den Pfad zum Anfang zeichnen möchte. \\

Die Implementation der Klasse Node sieht wie folgt aus:

\lstinputlisting[label=src:nodeClass,caption=Node-Class]{code/node.java}

\section{Polar-Diagramm}
\subsection{Parser}
Die Schiffsdaten sind als CSV\footnote{Comma Separated Values}-Datei gegeben
und werden von einem selbst\-geschriebenen Parser in ein passendes
Klassen-Konstrukt geladen. Die Schwierigkeit bestand darin, dass die Daten
nicht-dekoriert sind und daher nur durch ihre Position von anderen Typen zu
unterscheiden sind. Das bedeutet allerdings auch, dass der Parser sich auf
diese Datenstruktur verlässt und keine Abweichungen duldet und sonst abstürzt.

Dieses Problem ist allerdings vertretbar, da die Datenstruktur vorgegeben ist
und der Parser daran angepasst wurde. Es ist im Allgemeinen sehr schwierig
einen Parser für eine schwach typisierte Datenstruktur zu schreiben. Eine
robustere Datenstruktur würde XML bieten, die strikte Einschränkung bis hin zu
Datentypen für einzelne Felder bietet.

\subsection{Verarbeitungsklasse}
Die Klasse \texttt{BoatSpeedDiagram.java\footnote{Im Package
ch.zhaw.lakerouting.interpolation.boatdiagram zu finden}} verwaltet das
Polardiagram und bietet die nötigen Methoden für die Abfrage der Werte an,
kapselt die Interpolation, so das der Programmierer sich darum nicht kümmern
muss.

\subsection{Bilineare Interpolation}\label{sss:bilinearinterpolation}
Die Interpolation an sich ist durch 
\begin{equation}
f(x,y) \approx \begin{bmatrix} 1-x & x \end{bmatrix} \begin{bmatrix}
f(0,0) & f(0,1) \\ f(1,0) & f(1,1) \end{bmatrix} \begin{bmatrix} 1 - y
\\ y \end{bmatrix}
\label{eq:bilineareinterpolation}
\end{equation}
geben und kann in Java wie nachfolgend gezeigt, implementiert werden.

 \lstinputlisting[label=src:bilinearinterpolation,caption=Bilineare Interpolation]{code/BilinearInterpolation.java}
Die konkrete Berechnung erfolgt auf den Zeilen 17-19 und zeigen den einfachen
Charakter der Berechnung. Diese Implementation erfordert allerdings eine
geringe Aufbereitung der Eingabewerte, ist dafür einfacher zu testen und somit
indirekt auch weniger anfällig für Implementationsfehler, was direkt zu
robusterem Code führt.

\section{Windfelder}
Die Implementation ist vergleichsweise einfach gehalten und besteht aus einer
Klasse für ein einzelnes Windfeld mit Hilfsfunktionalitäten für die
Interpolation der Windvektoren und das Abfragen der Nachbarsvektoren an einer
bestimmten Position. Diese einzelnen Windfelder werden dann in einem Art Stapel
aufbewahrt\footnote{Wir verwenden der Einfachheit halber ein normales Array.}
Im Prinzip besteht das alles aus einer dreidimensionalen Struktur aus
Windvektoren.

\subsection{Windfeld-Parser}
Der Parser ist ein Eigenbau und wurde speziell für diese Datenstruktur
geschaffen. Diverse Unzulänglichkeiten wie nicht-leere Zeilen und Trailing
Spaces haben die Entwicklung erschwert und dementsprechend viel Zeit gekostet.

Allerdings lässt sich der Parser leicht auf andere Ressourcen erweitern wie zum
Beispiel HTTP und erlaubt auch die direkte Anbindung an Datenbanken.

\subsection{Interpolation der Windvektoren}
Da das Windfeld und das Entscheidungsnetz nicht über dieselben Koordinaten
verfügen und dementsprechend die Entscheidungspunkte normalerweise zwischen den
Windvektoren zu liegen kommen, wird nach Berechnung des Entscheidungsnetzes dem
Windfeld die Koordinatenliste übergeben. Das Windfeld interpoliert die
Windrichtung bzw. die Windvektoren an den geforderten Positionen. Das erfolgt
wie bereits in Abschnitt \ref{sss:bilinearinterpolation} erklärt über dieselbe
Klasse.

Nach dieser initialen Interpolation verfügen das Entscheidungsnetz und das
Windfeld über dieselben Array-Indizes und können somit leicht (wieder-)
verwendet werden.
